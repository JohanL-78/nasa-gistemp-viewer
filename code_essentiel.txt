=== ./test-nasa-fetch.js ===
// test-nasa-fetch.js - Testez chaque m√©thode individuellement
const { exec } = require('child_process');
const { promisify } = require('util');
const https = require('https');
const dns = require('dns');
const os = require('os');

const execAsync = promisify(exec);
const NASA_URL = 'https://data.giss.nasa.gov/gistemp/tabledata_v4/GLB.Ts+dSST.csv';

console.log('üß™ Test des diff√©rentes m√©thodes de r√©cup√©ration des donn√©es NASA\n');

// Test 1: curl
async function testCurl() {
  console.log('1Ô∏è‚É£ Test avec curl (IPv4):');
  try {
    const start = Date.now();
    const { stdout } = await execAsync(`curl -4 -L -s -m 10 "${NASA_URL}"`);
    const time = Date.now() - start;
    console.log(`   ‚úÖ Succ√®s! Temps: ${time}ms, Taille: ${stdout.length} caract√®res`);
    return true;
  } catch (error) {
    console.log(`   ‚ùå √âchec: ${error.message}`);
    return false;
  }
}

// Test 2: wget
async function testWget() {
  console.log('\n2Ô∏è‚É£ Test avec wget (IPv4):');
  try {
    const start = Date.now();
    const { stdout } = await execAsync(`wget -4 -q -O - --timeout=10 "${NASA_URL}"`);
    const time = Date.now() - start;
    console.log(`   ‚úÖ Succ√®s! Temps: ${time}ms, Taille: ${stdout.length} caract√®res`);
    return true;
  } catch (error) {
    console.log(`   ‚ùå √âchec: ${error.message}`);
    return false;
  }
}

// Test 3: fetch natif
async function testNativeFetch() {
  console.log('\n3Ô∏è‚É£ Test avec fetch natif:');
  console.log(`   Node.js version: ${process.version}`);
  
  if (typeof fetch === 'undefined') {
    console.log('   ‚ùå fetch non disponible (Node.js < 18)');
    return false;
  }
  
  try {
    const start = Date.now();
    const response = await fetch(NASA_URL, {
      signal: AbortSignal.timeout(10000)
    });
    const text = await response.text();
    const time = Date.now() - start;
    console.log(`   ‚úÖ Succ√®s! Temps: ${time}ms, Taille: ${text.length} caract√®res`);
    return true;
  } catch (error) {
    console.log(`   ‚ùå √âchec: ${error.message}`);
    return false;
  }
}

// Test 4: https natif avec IPv4
async function testHttpsNative() {
  console.log('\n4Ô∏è‚É£ Test avec https natif (IPv4 forc√©):');
  
  // Tester d'abord la r√©solution DNS
  try {
    dns.setDefaultResultOrder('ipv4first');
    const addresses = await promisify(dns.resolve4)('data.giss.nasa.gov');
    console.log(`   üì° Adresses IPv4 trouv√©es: ${addresses.join(', ')}`);
  } catch (error) {
    console.log(`   ‚ö†Ô∏è Erreur DNS: ${error.message}`);
  }
  
  return new Promise((resolve) => {
    const start = Date.now();
    const url = new URL(NASA_URL);
    
    const options = {
      hostname: url.hostname,
      port: 443,
      path: url.pathname,
      method: 'GET',
      headers: {
        'User-Agent': 'Mozilla/5.0 (compatible; Node.js test)',
        'Accept': 'text/csv'
      },
      family: 4, // IPv4 uniquement
      timeout: 10000
    };
    
    let data = '';
    
    const req = https.request(options, (res) => {
      console.log(`   üì• R√©ponse HTTP: ${res.statusCode}`);
      
      if (res.statusCode !== 200) {
        console.log(`   ‚ùå √âchec: HTTP ${res.statusCode}`);
        resolve(false);
        return;
      }
      
      res.on('data', (chunk) => {
        data += chunk;
      });
      
      res.on('end', () => {
        const time = Date.now() - start;
        console.log(`   ‚úÖ Succ√®s! Temps: ${time}ms, Taille: ${data.length} caract√®res`);
        resolve(true);
      });
    });
    
    req.on('error', (error) => {
      console.log(`   ‚ùå √âchec: ${error.message}`);
      resolve(false);
    });
    
    req.on('timeout', () => {
      console.log('   ‚ùå √âchec: Timeout');
      req.destroy();
      resolve(false);
    });
    
    req.end();
  });
}

// Ex√©cuter tous les tests
async function runAllTests() {
  const results = {
    curl: await testCurl(),
    wget: await testWget(),
    nativeFetch: await testNativeFetch(),
    httpsNative: await testHttpsNative()
  };
  
  console.log('\nüìä R√©sum√© des tests:');
  console.log('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');
  
  const working = Object.entries(results)
    .filter(([_, success]) => success)
    .map(([method]) => method);
  
  if (working.length > 0) {
    console.log(`‚úÖ M√©thodes fonctionnelles: ${working.join(', ')}`);
    console.log(`\nüí° Recommandation: La m√©thode "${working[0]}" est la plus rapide sur votre syst√®me.`);
  } else {
    console.log('‚ùå Aucune m√©thode n\'a fonctionn√©!');
    console.log('\nüîß Solutions possibles:');
    console.log('   - V√©rifier votre connexion internet');
    console.log('   - V√©rifier les param√®tres de firewall/proxy');
    console.log('   - Installer curl ou wget');
    console.log('   - Mettre √† jour Node.js vers la version 18+');
  }
  
  // Informations syst√®me utiles
  console.log('\nüìã Informations syst√®me:');
  console.log(`   - Node.js: ${process.version}`);
  console.log(`   - OS: ${process.platform} ${process.arch}`);
  
  // V√©rifier IPv6
  const interfaces = os.networkInterfaces();
  const hasIPv6 = Object.values(interfaces).flat().some(i => i.family === 'IPv6');
  console.log(`   - IPv6 support√©: ${hasIPv6 ? 'Oui' : 'Non'}`);
}

runAllTests().catch(console.error);=== ./app/layout.js ===
import "./globals.css";

export const metadata = {
  title: "NASA GISTEMP Temperature Anomaly Visualizer",
  description: "Visualisation des anomalies de temp√©rature globale avec Next.js et Three.js",
};

export default function RootLayout({ children }) {
  return (
    <html lang="fr">
      <body>
        <div className="main-container">
          {children}
        </div>
      </body>
    </html>
  );
}=== ./app/page.js ===
import Navbar from '@/components/Navbar';
import ClimateGlobe from '@/components/ClimateGlobe';
import DataTable from '@/components/DataTable';
import { getAvailableDates, getNasaTableData } from '@/lib/data';

export default async function HomePage() {
  // Ces fonctions s'ex√©cutent sur le serveur !
  const availableDates = await getAvailableDates();
  const tableData = await getNasaTableData();

  console.log("V√©rification des donn√©es sur le SERVEUR (3 premi√®res lignes) :");
  console.log(tableData.slice(0, 3));

  return (
    <>
      <Navbar />
      
      <main>
 

        {/* Section globe - maintenant pleine largeur */}
        <div className="globe-section">
          {/* Le composant client re√ßoit les donn√©es pr√©-charg√©es du serveur */}
          <ClimateGlobe availableDates={availableDates} />
        </div>
        {/*<div className="color-scale" style={{ display: 'flex', justifyContent: 'center'}}>
                <div className="scale-label">-5¬∞C</div>
                <div className="gradient"></div>
                <div className="scale-label">+5¬∞C</div>
              </div> */}

        <div className="data-section" id="data">
          <h2>Donn√©es mensuelles de temp√©rature globale</h2>
          {/* Le composant client re√ßoit les donn√©es pr√©-charg√©es du serveur */}
          <DataTable initialData={tableData} />
        </div>

        <div className="data-section" id="about">
          <h2>√Ä propos de ce projet</h2>
          <p>
            Cette application a √©t√© recr√©√©e avec Next.js 15 (App Router) et Three.js. Elle utilise les Server Components pour le rendu initial et les Server Actions pour les mises √† jour de donn√©es, offrant une exp√©rience rapide et moderne.
          </p>
          <p>
            Le code source est disponible sur <a href="#">GitHub</a>.
          </p>
        </div>
      </main>
    </>
  );
}=== ./app/api/table/route.js ===
// app/api/table/route.js
import { getNasaTableData } from '@/lib/data';

export async function GET(req) {
  const { searchParams } = new URL(req.url);
  const source = searchParams.get('source') || 'global';
  let data = await getNasaTableData(source);

  // Supprimer les lignes parasites comme "Land-Ocean: Global Means"
  if (data.length > 0 && !data[0][0].startsWith('Year')) {
    data = data.slice(1);
  }

  return Response.json(data);
}
=== ./components/DataTable.jsx ===
// components/DataTable.jsx
'use client';

import { useState, useEffect } from 'react';

export default function DataTable({ initialData }) {
  const [tableData, setTableData] = useState(initialData);
  const [sortOrder, setSortOrder] = useState({});
  const [source, setSource] = useState('global');

  useEffect(() => {
    async function fetchData() {
      try {
        const res = await fetch(`/api/table?source=${source}`);
        const data = await res.json();
        setTableData(data);
      } catch (error) {
        console.error("Erreur lors du chargement des donn√©es:", error);
      }
    }
    fetchData();
  }, [source]);

  const sortTableByColumn = (colIndex) => {
    const order = sortOrder[colIndex] === 'desc' ? 'asc' : 'desc';
    setSortOrder({ [colIndex]: order });

    const header = tableData[0];
    let rows = [...tableData.slice(1)];

    const numericSamples = rows.map(row => parseFloat(row[colIndex])).filter(v => !isNaN(v));
    const isNumeric = numericSamples.length > rows.length / 2;

    const parse = (val) => {
      const num = parseFloat(val);
      return isNaN(num) ? -Infinity : num;
    };

    rows.sort((a, b) => {
      if (isNumeric) {
        const aVal = parse(a[colIndex]);
        const bVal = parse(b[colIndex]);
        return order === 'desc' ? bVal - aVal : aVal - bVal;
      } else {
        const aVal = a[colIndex]?.toLowerCase?.() || '';
        const bVal = b[colIndex]?.toLowerCase?.() || '';
        if (aVal < bVal) return order === 'desc' ? 1 : -1;
        if (aVal > bVal) return order === 'desc' ? -1 : 1;
        return 0;
      }
    });

    setTableData([header, ...rows]);
  };

  if (!tableData || tableData.length < 2) {
    return <p>Donn√©es en cours de chargement ou indisponibles...</p>;
  }

  const header = tableData[0];
  const rows = tableData.slice(1);

  return (
    <div style={{ overflowX: 'auto' }}>
      <div style={{ marginBottom: '1rem' }}>
        <label htmlFor="source">Choisir la r√©gion : </label>
        <select id="source" value={source} onChange={(e) => setSource(e.target.value)}>
          <option value="global">Global</option>
          <option value="north">H√©misph√®re Nord</option>
          <option value="south">H√©misph√®re Sud</option>
        </select>
      </div>

      <table className="data-table">
        <thead>
          <tr>
            {header.map((headerText, index) => (
              <th key={index} onClick={() => sortTableByColumn(index)} style={{ cursor: 'pointer' }}>
                {headerText}
              </th>
            ))}
          </tr>
        </thead>
        <tbody>
          {rows.map((row, rowIndex) => (
            <tr key={rowIndex}>
              {row.map((cell, cellIndex) => {
                let style = {};
                if (cellIndex > 0 && !isNaN(parseFloat(cell))) {
                  const temp = parseFloat(cell);
                  if (temp > 0) {
                    const intensity = Math.min(255, Math.floor(temp * 100));
                    style.backgroundColor = `rgba(255, ${255 - intensity}, ${255 - intensity}, 0.7)`;
                  } else if (temp < 0) {
                    const intensity = Math.min(255, Math.floor(Math.abs(temp) * 100));
                    style.backgroundColor = `rgba(${255 - intensity}, ${255 - intensity}, 255, 0.7)`;
                  }
                }
                return <td key={cellIndex} style={style}>{cell}</td>;
              })}
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
}
=== ./components/Navbar.jsx ===
import Link from 'next/link';

export default function Navbar() {
  return (
    <nav>
      <div className="logo">Nasa Gistemp Viewer</div>
      <ul>
        <li><Link href="/">Home</Link></li>
        <li><Link href="#visualization">Visualisation</Link></li>
        <li><Link href="#data">Donn√©es</Link></li>
        <li><Link href="#about">√Ä propos</Link></li>
      </ul>
    </nav>
  );
}=== ./components/ClimateGlobe.jsx ===
'use client';

import { useState, useEffect, useRef, Suspense } from 'react';
import { Canvas, useFrame, extend } from '@react-three/fiber';
import { OrbitControls } from '@react-three/drei';
import { motion, AnimatePresence } from 'framer-motion';
import { Calendar, Globe2, Thermometer, Snowflake, Mountain, Waves, Settings } from 'lucide-react';
import * as THREE from 'three';
import { getTemperatureDataAction } from '@/lib/actions';

function useIsMobile() {
  const [isMobile, setIsMobile] = useState(false);
  useEffect(() => {
    const check = () => setIsMobile(window.innerWidth < 768);
    check();
    window.addEventListener('resize', check);
    return () => window.removeEventListener('resize', check);
  }, []);
  return isMobile;
}

extend({
  SphereGeometry: THREE.SphereGeometry,
  MeshLambertMaterial: THREE.MeshLambertMaterial,
  MeshBasicMaterial: THREE.MeshBasicMaterial,
});

const ModernInput = ({ value, onChange, placeholder, icon: Icon }) => {
  const isMobile = useIsMobile();
  
  return (
    <motion.div 
      className="input-container"
      whileHover={{ scale: 1.02 }}
      whileTap={{ scale: 0.98 }}
      style={{
        position: 'relative',
        marginBottom: isMobile ? '6px' : '1rem'
      }}
    >
      <div style={{
        position: 'absolute',
        left: isMobile ? '8px' : '12px',
        top: '50%',
        transform: 'translateY(-50%)',
        zIndex: 2,
        color: '#64b5f6'
      }}>
        <Icon size={isMobile ? 14 : 18} />
      </div>
      <input 
        type="text" 
        value={value} 
        onChange={onChange} 
        placeholder={placeholder}
        style={{
          width: '100%',
          padding: isMobile ? '8px 8px 8px 30px' : '12px 12px 12px 45px',
          background: 'rgba(255, 255, 255, 0.05)',
          backdropFilter: 'blur(10px)',
          border: '1px solid rgba(255, 255, 255, 0.1)',
          borderRadius: isMobile ? '8px' : '12px',
          color: '#fff',
          fontSize: isMobile ? '12px' : '14px',
          outline: 'none',
          transition: 'all 0.3s ease',
          boxShadow: '0 4px 15px rgba(0, 0, 0, 0.1)'
        }}
        onFocus={(e) => {
          e.target.style.border = '1px solid rgba(100, 181, 246, 0.5)';
          e.target.style.boxShadow = '0 0 20px rgba(100, 181, 246, 0.2)';
        }}
        onBlur={(e) => {
          e.target.style.border = '1px solid rgba(255, 255, 255, 0.1)';
          e.target.style.boxShadow = '0 4px 15px rgba(0, 0, 0, 0.1)';
        }}
      />
    </motion.div>
  );
};

const DataCard = ({ icon: Icon, label, value, color }) => {
  const isMobile = useIsMobile();
  
  return (
    <motion.div
      whileHover={{ scale: 1.05, y: -2 }}
      whileTap={{ scale: 0.95 }}
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ duration: 0.5 }}
      style={{
        background: `linear-gradient(135deg, rgba(255, 255, 255, 0.1) 0%, rgba(255, 255, 255, 0.05) 100%)`,
        backdropFilter: 'blur(15px)',
        border: `1px solid ${color}40`,
        borderRadius: isMobile ? '8px' : '16px',
        padding: isMobile ? '6px' : '16px',
        display: 'flex',
        flexDirection: isMobile ? 'column' : 'row',
        alignItems: 'center',
        gap: isMobile ? '4px' : '12px',
        cursor: 'pointer',
        transition: 'all 0.3s ease',
        boxShadow: `0 8px 25px rgba(0, 0, 0, 0.1), 0 0 20px ${color}10`,
        minHeight: isMobile ? '60px' : 'auto'
      }}
    >
      <motion.div 
        style={{
          background: `linear-gradient(135deg, ${color}60, ${color}40)`,
          borderRadius: isMobile ? '6px' : '12px',
          padding: isMobile ? '4px' : '10px',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          position: 'relative',
          flexShrink: 0
        }}
        whileHover={{
          boxShadow: `0 0 30px ${color}60, 0 0 60px ${color}30`,
          scale: 1.1
        }}
        initial={{ boxShadow: `0 0 0px ${color}00` }}
        animate={{ 
          boxShadow: [
            `0 0 0px ${color}00`,
            `0 0 20px ${color}40`,
            `0 0 0px ${color}00`
          ]
        }}
        transition={{ 
          duration: 3, 
          repeat: Infinity, 
          ease: "easeInOut",
          delay: Math.random() * 2
        }}
      >
        <Icon size={isMobile ? 12 : 20} color={color} />
      </motion.div>
      <div style={{ 
        flex: 1, 
        textAlign: isMobile ? 'center' : 'left',
        minWidth: 0
      }}>
        <div style={{ 
          fontSize: isMobile ? '8px' : '12px', 
          color: '#bbb', 
          marginBottom: '1px', 
          fontWeight: '500',
          whiteSpace: isMobile ? 'nowrap' : 'normal',
          overflow: 'hidden',
          textOverflow: 'ellipsis'
        }}>
          {label}
        </div>
        <div style={{ 
          fontSize: isMobile ? '11px' : '18px', 
          fontWeight: '700', 
          color: color, 
          textShadow: `0 0 10px ${color}50`,
          whiteSpace: 'nowrap'
        }}>
          {value !== null ? `${value?.toFixed(2)}¬∞C` : 'N/A'}
        </div>
      </div>
    </motion.div>
  );
};

const Globe = ({ year, month, isVisible, autoRotate, onLoad, globeRef }) => {
  const groupRef = useRef();
  const baseMeshRef = useRef();
  const [temperatureTexture, setTemperatureTexture] = useState(null);
  const [overlayTexture, setOverlayTexture] = useState(null);
  const [isLoading, setIsLoading] = useState(false);
  const [lastLoadedKey, setLastLoadedKey] = useState('');
  const instanceId = useRef(Math.random().toString(36).slice(2, 11)).current;

  useFrame(() => {
    if (autoRotate && groupRef.current) groupRef.current.rotation.y += 0.0016;
  });

  useEffect(() => {
    const key = `${year}_${month}`;
    if (!baseMeshRef.current || isLoading || lastLoadedKey === key) return;
    setIsLoading(true);
    const loader = new THREE.TextureLoader();
    const url = `/textures/gistemp_${key}.png?i=${instanceId}&t=${Date.now()}`;
    const setupTexture = (tex) => {
      tex.magFilter = THREE.LinearFilter;
      tex.minFilter = THREE.LinearMipMapLinearFilter;
      tex.wrapS = THREE.ClampToEdgeWrapping;
      tex.wrapT = THREE.ClampToEdgeWrapping;
      tex.flipY = true;
      tex.needsUpdate = true;
      tex.uuid = THREE.MathUtils.generateUUID();
    };

    loader.load(
      url,
      (tex) => {
        tex.colorSpace = THREE.SRGBColorSpace;
        tex.magFilter = THREE.LinearFilter;
        tex.minFilter = THREE.LinearFilter;
        tex.generateMipmaps = false;
        tex.wrapS = THREE.ClampToEdgeWrapping;
        tex.wrapT = THREE.ClampToEdgeWrapping;
        tex.flipY = true;
        tex.needsUpdate = true;
        tex.uuid = THREE.MathUtils.generateUUID();

        setTemperatureTexture(tex);
        const mat = baseMeshRef.current.material;
        if (mat.map) mat.map.dispose();
        mat.map = tex;
        mat.needsUpdate = true;
        mat.uuid = THREE.MathUtils.generateUUID();
        setLastLoadedKey(key);
        setIsLoading(false);
      },
      undefined,
      () => {
        loader.load(`/textures/default_earth.jpg?i=${instanceId}&t=${Date.now()}`, (tex) => {
          tex.colorSpace = THREE.SRGBColorSpace;
          tex.magFilter = THREE.LinearFilter;
          tex.minFilter = THREE.LinearFilter;
          tex.generateMipmaps = false;
          tex.wrapS = THREE.ClampToEdgeWrapping;
          tex.wrapT = THREE.ClampToEdgeWrapping;
          tex.flipY = true;
          tex.needsUpdate = true;
          tex.uuid = THREE.MathUtils.generateUUID();

          setTemperatureTexture(tex);
          const mat = baseMeshRef.current.material;
          if (mat.map) mat.map.dispose();
          mat.map = tex;
          mat.needsUpdate = true;
          mat.uuid = THREE.MathUtils.generateUUID();
          setLastLoadedKey(key);
          setIsLoading(false);
        });
      }
    );

    if (onLoad && lastLoadedKey !== key) {
      getTemperatureDataAction(year, month)
        .then((res) => onLoad(res ?? {}))
        .catch(() => setIsLoading(false));
    }

  }, [year, month, onLoad, lastLoadedKey, isLoading, instanceId]);

  useEffect(() => {
    if (overlayTexture) return;
    const loader = new THREE.TextureLoader();
    loader.load(`/textures/overlay.png?i=${instanceId}&t=${Date.now()}`, (tex) => {
      tex.magFilter = THREE.LinearFilter;
      tex.minFilter = THREE.LinearMipMapLinearFilter;
      tex.anisotropy = 8;
      tex.wrapS = THREE.ClampToEdgeWrapping;
      tex.wrapT = THREE.ClampToEdgeWrapping;
      tex.needsUpdate = true;
      tex.colorSpace = THREE.SRGBColorSpace;
      tex.uuid = THREE.MathUtils.generateUUID();
      setOverlayTexture(tex);
    });
  }, [overlayTexture, instanceId]);

  useEffect(() => {
    if (globeRef) globeRef.current = { group: groupRef.current, base: baseMeshRef.current, instanceId };
  }, [globeRef, instanceId]);

  useEffect(() => () => {
    temperatureTexture?.dispose();
    overlayTexture?.dispose();
  }, [temperatureTexture, overlayTexture]);

  return (
    <group ref={groupRef} rotation-x={0.2} visible={isVisible}>
      <mesh ref={baseMeshRef} rotation-x={0.2}>
        <sphereGeometry args={[1, 128, 64]} />
        <meshBasicMaterial map={temperatureTexture} transparent={true} toneMapped={false} />
      </mesh>
      {overlayTexture && (
        <mesh rotation-x={0.2}>
          <sphereGeometry args={[1.001, 128, 64]} />
          <meshBasicMaterial map={overlayTexture} transparent opacity={0.43} depthWrite={false} blending={THREE.MultiplyBlending} alphaTest={0.1} />
        </mesh>
      )}
    </group>
  );
};

const Scene = ({ children }) => (
  <>
    <hemisphereLight skyColor={0xffffff} groundColor={0x888888} intensity={1.5} />
    <directionalLight
      position={[0, -3, 0]}      // vient du dessous
      intensity={0.5}
      color={0xffffff}
    />
    {children}
  </>
);

export default function CanvasGlobe({ availableDates }) {
  const isMobile = useIsMobile();
  const [autoRotate, setAutoRotate] = useState(true);
  const [controlsOpen, setControlsOpen] = useState(true);
  const [year, setYear] = useState(availableDates.current_year);
  const [month, setMonth] = useState(availableDates.current_month);
  const [temps, setTemps] = useState({});
  const globeRef = useRef(null);

  const sidebarVariants = {
    hidden: {
      x: isMobile ? 0 : -300,
      y: isMobile ? -300 : 0,
      opacity: 0
    },
    visible: {
      x: 0,
      y: 0,
      opacity: 1,
      transition: {
        type: "spring",
        damping: 25,
        stiffness: 200,
        duration: 0.6
      }
    }
  };

  const overlayVariants = {
    hidden: { x: 400, opacity: 0 },
    visible: { 
      x: 0, 
      opacity: 1,
      transition: {
        type: "spring",
        damping: 20,
        stiffness: 200
      }
    }
  };

  const overlayStyle = {
    position: 'absolute',
    top: '2.3rem',
    right: '4.5rem',
    transform: 'translateY(-50%)',
    zIndex: 10,
    background: 'rgba(0, 0, 0, 0.8)',
    backdropFilter: 'blur(20px)',
    padding: '16px 20px',
    borderRadius: '16px',
    border: '1px solid rgba(255, 255, 255, 0.1)',
    color: '#fff',
    maxWidth: isMobile ? 'calc(100% - 5rem)' : '280px',
    boxShadow: '0 20px 40px rgba(0, 0, 0, 0.3)'
  };

  return (
    <div style={{ 
      display: 'flex', 
      flexDirection: isMobile ? 'column' : 'row', 
      height: '90vh', 
      width: '100%',
      background: 'linear-gradient(135deg, #0f0f0f 0%, #1a1a2e 100%)'
    }}>
      <motion.div
        variants={sidebarVariants}
        initial="hidden"
        animate="visible"
        style={{
          width: isMobile ? '100%' : '320px',
          height: isMobile ? 'auto' : '90vh',
          maxHeight: isMobile ? '40vh' : '90vh',
          flexShrink: 0,
          background: 'linear-gradient(180deg, rgba(26, 26, 46, 0.95) 0%, rgba(15, 15, 15, 0.95) 100%)',
          backdropFilter: 'blur(20px)',
          border: isMobile ? 'none' : '1px solid rgba(255, 255, 255, 0.1)',
          borderBottom: isMobile ? '1px solid rgba(255, 255, 255, 0.1)' : 'none',
          color: '#fff',
          padding: isMobile ? '12px' : '24px',
          boxShadow: isMobile ? '0 4px 25px rgba(0,0,0,0.3)' : '4px 0 25px rgba(0,0,0,0.3)',
          zIndex: isMobile ? 15 : 5,
          position: isMobile ? 'relative' : 'static',
          overflow: 'visible',
          display: 'flex',
          flexDirection: isMobile ? 'row' : 'column',
          gap: isMobile ? '12px' : '24px'
        }}
      >
        <motion.div
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ delay: 0.2 }}
          style={{ flex: isMobile ? '1' : 'none' }}
        >
          <div style={{ 
            display: 'flex', 
            alignItems: 'center', 
            gap: '8px', 
            marginBottom: isMobile ? '8px' : '24px',
            padding: isMobile ? '8px' : '16px',
            background: 'linear-gradient(135deg, rgba(100, 181, 246, 0.15), rgba(100, 181, 246, 0.08))',
            borderRadius: '12px',
            border: '1px solid rgba(100, 181, 246, 0.3)'
          }}>
            <motion.div
              animate={{ 
                boxShadow: [
                  '0 0 0px #64b5f600',
                  '0 0 20px #64b5f650',
                  '0 0 0px #64b5f600'
                ]
              }}
              transition={{ 
                duration: 2.5, 
                repeat: Infinity, 
                ease: "easeInOut" 
              }}
            >
              <Calendar size={isMobile ? 16 : 24} color="#64b5f6" />
            </motion.div>
            <h3 style={{ 
              margin: 0, 
              fontSize: isMobile ? '14px' : '18px', 
              fontWeight: '600',
              background: 'linear-gradient(135deg, #64b5f6, #42a5f5)',
              WebkitBackgroundClip: 'text',
              WebkitTextFillColor: 'transparent'
            }}>
              {isMobile ? 'P√©riode' : 'P√©riode de Donn√©es'}
            </h3>
          </div>

          <ModernInput 
            value={year} 
            onChange={(e) => setYear(e.target.value)} 
            placeholder="Ann√©e" 
            icon={Calendar}
          />
          <ModernInput 
            value={month} 
            onChange={(e) => setMonth(e.target.value)} 
            placeholder="Mois" 
            icon={Calendar}
          />
        </motion.div>

        <motion.div
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ delay: 0.4 }}
          style={{
            background: 'linear-gradient(135deg, rgba(255, 255, 255, 0.05), rgba(255, 255, 255, 0.02))',
            borderRadius: '16px',
            padding: isMobile ? '8px' : '20px',
            border: '1px solid rgba(255, 255, 255, 0.1)',
            flex: isMobile ? '2' : 'none'
          }}
        >
          <div style={{ 
            display: 'flex', 
            alignItems: 'center', 
            gap: '8px', 
            marginBottom: isMobile ? '8px' : '16px'
          }}>
            <motion.div
              animate={{ 
                boxShadow: [
                  '0 0 0px #ff6b6b00',
                  '0 0 25px #ff6b6b60',
                  '0 0 0px #ff6b6b00'
                ]
              }}
              transition={{ 
                duration: 3, 
                repeat: Infinity, 
                ease: "easeInOut",
                delay: 0.5
              }}
            >
              <Thermometer size={isMobile ? 14 : 20} color="#ff6b6b" />
            </motion.div>
            <h4 style={{ 
              margin: 0, 
              fontSize: isMobile ? '12px' : '16px', 
              fontWeight: '600',
              color: '#fff'
            }}>
              {isMobile ? 'Donn√©es' : 'Donn√©es Climatiques'}
            </h4>
          </div>
          
          <div style={{
            display: 'grid',
            gridTemplateColumns: isMobile ? '1fr 1fr' : '1fr',
            gap: isMobile ? '6px' : '12px'
          }}>
            <DataCard 
              icon={Globe2} 
              label="Global" 
              value={temps.global} 
              color="#00d4ff"
            />
            
            <DataCard 
              icon={Snowflake} 
              label="Nord" 
              value={temps.north} 
              color="#00ff88"
            />
            
            <DataCard 
              icon={Mountain} 
              label="Sud" 
              value={temps.south} 
              color="#ff8c00"
            />
            
            <DataCard 
              icon={Waves} 
              label="ONI" 
              value={temps.oni} 
              color="#ff0080"
            />
          </div>
        </motion.div>
      </motion.div>

      <div style={{
        flexGrow: 1,
        minWidth: 0,
        maxWidth: '100%',
        height: isMobile ? 'auto' : '90vh',
        minHeight: isMobile ? '50vh' : '90vh',
        position: 'relative',
        zIndex: 1
      }}>
        <motion.button 
          onClick={() => setControlsOpen((o) => !o)} 
          aria-label="Ouvrir les commandes"
          whileHover={{ scale: 1.1, rotate: 180 }}
          whileTap={{ scale: 0.9 }}
          animate={{
            boxShadow: [
              '0 8px 25px rgba(0, 0, 0, 0.3)',
              '0 8px 25px rgba(0, 0, 0, 0.3), 0 0 30px rgba(100, 181, 246, 0.4)',
              '0 8px 25px rgba(0, 0, 0, 0.3)'
            ]
          }}
          transition={{
            duration: 2,
            repeat: Infinity,
            ease: "easeInOut"
          }}
          style={{
            position: 'absolute',
            right: '1rem',
            top: '2rem',
            zIndex: 11,
            width: '48px',
            height: '48px',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            background: 'linear-gradient(135deg, rgba(0, 0, 0, 0.8), rgba(26, 26, 46, 0.8))',
            backdropFilter: 'blur(20px)',
            color: '#64b5f6',
            borderRadius: '50%',
            border: '1px solid rgba(100, 181, 246, 0.3)',
            outline: 'none',
            cursor: 'pointer',
            transition: 'all 0.3s ease'
          }}
        >
          <motion.div
            animate={{
              filter: [
                'drop-shadow(0 0 0px #64b5f600)',
                'drop-shadow(0 0 8px #64b5f680)',
                'drop-shadow(0 0 0px #64b5f600)'
              ]
            }}
            transition={{
              duration: 2.5,
              repeat: Infinity,
              ease: "easeInOut",
              delay: 1
            }}
          >
            <Settings size={20} />
          </motion.div>
        </motion.button>

        <AnimatePresence>
          {controlsOpen && (
            <motion.div
              variants={overlayVariants}
              initial="hidden"
              animate="visible"
              exit="hidden"
              style={overlayStyle}
            >
              <motion.label 
                style={{ 
                  display: 'flex', 
                  alignItems: 'center', 
                  gap: '12px',
                  cursor: 'pointer'
                }}
                whileHover={{ scale: 1.02 }}
                whileTap={{ scale: 0.98 }}
              >
                <input 
                  type="checkbox" 
                  checked={autoRotate} 
                  onChange={(e) => setAutoRotate(e.target.checked)} 
                  style={{ 
                    accentColor: '#64b5f6',
                    width: '18px',
                    height: '18px'
                  }} 
                />
                <span style={{ fontSize: '14px', fontWeight: '500' }}>
                  Rotation automatique
                </span>
              </motion.label>
            </motion.div>
          )}
        </AnimatePresence>

        <Canvas 
          key={`${year}-${month}`} 
          camera={{ position: [0, 0, 2.5], fov: 75 }} 
          gl={{ antialias: true, alpha: true }} 
          style={{ width: '100%', height: '100%' }}
        >
          <Suspense fallback={null}>
            <Scene>
              <Globe 
                year={year} 
                month={month} 
                isVisible={true} 
                autoRotate={autoRotate} 
                onLoad={setTemps} 
                globeRef={globeRef} 
              />
            </Scene>
            <OrbitControls 
              enableDamping 
              dampingFactor={0.1} 
              zoomSpeed={0.3} 
              minDistance={2} 
              maxDistance={5} 
              enablePan={false} 
            />
          </Suspense>
        </Canvas>
      </div>
    </div>
  );
}=== ./lib/actions.js ===
'use server';

import { getTemperatureForDate, getOniIndex } from './data';

export async function getTemperatureDataAction(year, month) {
  try {
    // R√©cup√©ration des 3 temp√©ratures et de l‚ÄôONI en parall√®le
    const [globalTemp, northTemp, southTemp, oni] = await Promise.all([
      getTemperatureForDate(year, month, 'global'),
      getTemperatureForDate(year, month, 'north'),
      getTemperatureForDate(year, month, 'south'),
      getOniIndex(year, month)
    ]);

    const result = {
      temperature: globalTemp, // r√©trocompatibilit√©
      global: globalTemp,
      north: northTemp,
      south: southTemp,
      oni
    };

    console.log('üå°Ô∏è R√©sultat temp√©rature p√©riode A :', result);
    return result;

  } catch (error) {
    console.error(`Erreur dans la Server Action getTemperatureDataAction: ${error.message}`);
    return { 
      error: 'Impossible de r√©cup√©rer les temp√©ratures.',
      temperature: null,
      global: null,
      north: null,
      south: null,
      oni: null
    };
  }
}
=== ./lib/data.js ===
// lib/data.js - Version optimis√©e pour plusieurs sources NASA (GLB, NH, SH) + ONI
import fs from 'fs/promises';
import path from 'path';
import https from 'https';
import dns from 'dns';

dns.setDefaultResultOrder('ipv4first');

const CACHE_DURATION = 2 * 24 * 60 * 60 * 1000; // 48 heures

const NASA_URLS = {
  global: 'https://data.giss.nasa.gov/gistemp/tabledata_v4/GLB.Ts+dSST.csv',
  north: 'https://data.giss.nasa.gov/gistemp/tabledata_v4/NH.Ts+dSST.csv',
  south: 'https://data.giss.nasa.gov/gistemp/tabledata_v4/SH.Ts+dSST.csv',
};

const CACHE_FILES = {
  global: path.join(process.cwd(), 'cache_global.csv'),
  north: path.join(process.cwd(), 'cache_nh.csv'),
  south: path.join(process.cwd(), 'cache_sh.csv'),
};

const fetchLocks = {
  global: { isFetching: false, promise: null },
  north: { isFetching: false, promise: null },
  south: { isFetching: false, promise: null },
};

const ONI_URL = 'https://www.cpc.ncep.noaa.gov/data/indices/oni.ascii.txt';
const CACHE_FILE_ONI = path.join(process.cwd(), 'cache_oni.txt');

// --- NASA FETCH ---
function fetchNasaData(source = 'global') {
  return new Promise((resolve, reject) => {
    const url = new URL(NASA_URLS[source]);
    console.log(`üì± R√©cup√©ration des donn√©es NASA (${source}) via ${url.hostname}`);

    const options = {
      hostname: url.hostname,
      port: 443,
      path: url.pathname,
      method: 'GET',
      headers: {
        'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7)',
        'Accept': 'text/csv,*/*',
        'Accept-Language': 'fr-FR,fr;q=0.9,en;q=0.8',
        'Cache-Control': 'no-cache'
      },
      family: 4,
      timeout: 30000
    };

    let data = '';

    const req = https.request(options, (res) => {
      console.log(`üóïÔ∏è R√©ponse re√ßue: HTTP ${res.statusCode}`);

      if (res.statusCode >= 300 && res.statusCode < 400 && res.headers.location) {
        console.log(`‚Ü™ Redirection vers: ${res.headers.location}`);
        fetchNasaData(source).then(resolve).catch(reject);
        return;
      }

      if (res.statusCode !== 200) {
        reject(new Error(`Erreur HTTP ${res.statusCode}: ${res.statusMessage}`));
        return;
      }

      res.setEncoding('utf8');
      res.on('data', (chunk) => data += chunk);
      res.on('end', () => {
        console.log(`‚úÖ Donn√©es re√ßues: ${data.length} caract√®res`);
        resolve(data);
      });
    });

    req.on('error', (error) => {
      console.error(`‚ùå Erreur de connexion: ${error.message}`);
      reject(error);
    });

    req.on('timeout', () => {
      console.error('‚ùå Timeout de la requ√™te');
      req.destroy();
      reject(new Error('Timeout de connexion (30s)'));
    });

    req.end();
  });
}

export async function fetchAndCacheNasaData(source = 'global') {
  const CACHE_FILE = CACHE_FILES[source];
  const lock = fetchLocks[source];
  const stats = await fs.stat(CACHE_FILE).catch(() => null);
  const age = stats ? Date.now() - stats.mtimeMs : Infinity;

  if (age < CACHE_DURATION) {
    console.log(`‚úÖ Cache valide (${source}) (√¢ge: ${Math.round(age / 60000)} min)`);
    return;
  }

  if (lock.isFetching && lock.promise) {
    console.log(`‚è≥ Attente d'une mise √† jour du cache (${source}) d√©j√† en cours...`);
    await lock.promise;
    return;
  }

  lock.isFetching = true;
  lock.promise = (async () => {
    try {
      console.log(`üöÄ D√©but mise √† jour du cache (${source}) (√¢ge: ${Math.round(age / 60000)} min)`);
      const rawData = await fetchNasaData(source);

      if (!rawData || rawData.length < 1000 || !rawData.includes('Year,Jan')) {
        throw new Error("Donn√©es invalides ou incompl√®tes");
      }

      const cleanedData = rawData.replace(/\*\*\*/g, '');
      await fs.writeFile(CACHE_FILE, cleanedData);
      console.log("üìÇ Cache mis √† jour avec succ√®s !");
    } catch (error) {
      console.error(`‚ùå √âchec de la mise √† jour du cache (${source}): ${error.message}`);

      if (stats && stats.size > 0) {
        console.warn("‚ö†Ô∏è Utilisation du cache expir√©");
        return;
      }

      console.warn("üè¢ Cr√©ation d'un cache d'urgence minimal...");
      const emergencyData = `Year,Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec,J-D,D-N,DJF,MAM,JJA,SON\n2024,1.20,1.37,1.28,1.11,1.05,1.17,1.21,1.23,1.17,1.15,1.12,1.15,1.19,,1.23,1.15,1.20,1.15\n2023,0.87,0.97,1.20,1.00,0.93,1.08,1.19,1.27,1.49,1.37,1.46,1.52,1.19,1.15,0.95,1.04,1.18,1.44\n2022,0.91,0.89,1.05,0.84,0.84,0.92,0.93,0.95,0.90,0.97,0.72,0.79,0.89,0.94,1.16,0.91,0.93,0.86`;
      await fs.writeFile(CACHE_FILE, emergencyData);
      console.log("‚úÖ Cache d'urgence cr√©√©");
    } finally {
      lock.isFetching = false;
      lock.promise = null;
    }
  })();

  return lock.promise;
}

// --- Parsing CSV NASA ---
async function parseCSV(source = 'global') {
  await fetchAndCacheNasaData(source);
  const CACHE_FILE = CACHE_FILES[source];
  const csvData = await fs.readFile(CACHE_FILE, 'utf-8');
  const lines = csvData.trim().split('\n');
  const dataLines = lines.slice(1);
  return dataLines.map(line => line.split(',').map(cell => cell.trim()));
}

export async function getAvailableDates(source = 'global') {
  const parsedData = await parseCSV(source);
  const years = parsedData.map(row => row[0]).filter(Boolean).map(Number);

  const lastValid = [...parsedData].reverse().find(row =>
    row.some((cell, i) => i > 0 && !isNaN(parseFloat(cell)))
  );

  const current_year = lastValid?.[0];
  const current_month = (() => {
    if (!lastValid) return '01';
    let lastMonthIndex = -1;
    for (let i = 1; i <= 12; i++) {
      if (!isNaN(parseFloat(lastValid[i]))) {
        lastMonthIndex = i;
      }
    }
    return String(lastMonthIndex).padStart(2, '0');
  })();

  const months = [
    { value: "01", name: "Jan" }, { value: "02", name: "F√©v" }, { value: "03", name: "Mar" },
    { value: "04", name: "Avr" }, { value: "05", name: "Mai" }, { value: "06", name: "Juin" },
    { value: "07", name: "Juil" }, { value: "08", name: "Ao√ª" }, { value: "09", name: "Sep" },
    { value: "10", name: "Oct" }, { value: "11", name: "Nov" }, { value: "12", name: "D√©c" }
  ];

  return {
    years: years.sort((a, b) => b - a),
    months,
    current_year,
    current_month
  };
}

export async function getNasaTableData(source = 'global') {
  await fetchAndCacheNasaData(source);
  const CACHE_FILE = CACHE_FILES[source];
  const csvData = await fs.readFile(CACHE_FILE, 'utf-8');
  const lines = csvData.trim().split('\n');
  const header = lines[0].split(',').map(cell => cell.trim());
  const dataLines = lines.slice(1);
  const parsedData = dataLines.map(line => line.split(',').map(cell => cell.trim()));
  return [header, ...parsedData];
}

export async function getTemperatureForDate(year, month, source = 'global') {
  const parsedData = await parseCSV(source);
  const monthIndex = parseInt(month, 10);
  if (monthIndex < 1 || monthIndex > 12) return null;
  const colIndex = monthIndex;
  const yearRow = parsedData.find(row => row[0] === String(year));
  if (!yearRow || !yearRow[colIndex] || yearRow[colIndex] === '') return null;
  return parseFloat(yearRow[colIndex]);
}

// --- ONI FETCH & PARSE ---
export async function fetchAndCacheOniData() {
  const stats = await fs.stat(CACHE_FILE_ONI).catch(() => null);
  const age = stats ? Date.now() - stats.mtimeMs : Infinity;
  if (age < CACHE_DURATION) return;

  try {
    const raw = await new Promise((resolve, reject) => {
      const url = new URL(ONI_URL);
      const options = {
        hostname: url.hostname,
        path: url.pathname,
        method: 'GET',
        family: 4,
        timeout: 10000
      };
      let data = '';
      const req = https.request(options, res => {
        res.on('data', chunk => data += chunk);
        res.on('end', () => resolve(data));
      });
      req.on('error', reject);
      req.on('timeout', () => {
        req.destroy();
        reject(new Error("Timeout ONI"));
      });
      req.end();
    });

    console.log("‚úÖ Contenu ONI r√©cup√©r√©, √©criture en cours");
    await fs.writeFile(CACHE_FILE_ONI, raw);
    console.log("‚úÖ Cache ONI mis √† jour");
  } catch (err) {
    console.error("‚ùå √âchec r√©cup√©ration ONI:", err.message);
  }
}

const oniSeasonByMonth = {
  '01': 'NDJ', '02': 'DJF', '03': 'JFM', '04': 'FMA',
  '05': 'MAM', '06': 'AMJ', '07': 'MJJ', '08': 'JJA',
  '09': 'JAS', '10': 'ASO', '11': 'SON', '12': 'OND'
};

function getOniSeasonAndYear(year, month) {
  const season = oniSeasonByMonth[month];
  const y = parseInt(year, 10);
  if (season === 'NDJ') return { season, year: y - 1 };
  return { season, year: y };
}

export async function getOniIndex(year, month) {
  await fetchAndCacheOniData();
  const content = await fs.readFile(CACHE_FILE_ONI, 'utf-8');

  const { season, year: oniYear } = getOniSeasonAndYear(year, month);
  const lines = content.trim().split('\n');

  console.log(`üîé Recherche ONI pour ${oniYear} ${season}...`);

  for (const line of lines) {
    const parts = line.trim().split(/\s+/);
    if (parts.length < 4) continue;

    const tri = parts[0].trim().toUpperCase(); // ex: DJF
    const yr = parseInt(parts[1]);             // ex: 1950
    const val = parseFloat(parts[3]);          // ex: -1.53


    if (tri === season.toUpperCase() && yr === oniYear) {
      console.log(`‚úÖ Trouv√© ONI: ${val} (${season} ${oniYear})`);
      return isNaN(val) ? null : val;
    }
  }

  console.warn(`‚ùå Aucune donn√©e ONI trouv√©e pour ${oniYear} ${season}`);
  return null;
}