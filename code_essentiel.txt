=== ./test-nasa-fetch.js ===
// test-nasa-fetch.js - Testez chaque m√©thode individuellement
const { exec } = require('child_process');
const { promisify } = require('util');
const https = require('https');
const dns = require('dns');
const os = require('os');

const execAsync = promisify(exec);
const NASA_URL = 'https://data.giss.nasa.gov/gistemp/tabledata_v4/GLB.Ts+dSST.csv';

console.log('üß™ Test des diff√©rentes m√©thodes de r√©cup√©ration des donn√©es NASA\n');

// Test 1: curl
async function testCurl() {
  console.log('1Ô∏è‚É£ Test avec curl (IPv4):');
  try {
    const start = Date.now();
    const { stdout } = await execAsync(`curl -4 -L -s -m 10 "${NASA_URL}"`);
    const time = Date.now() - start;
    console.log(`   ‚úÖ Succ√®s! Temps: ${time}ms, Taille: ${stdout.length} caract√®res`);
    return true;
  } catch (error) {
    console.log(`   ‚ùå √âchec: ${error.message}`);
    return false;
  }
}

// Test 2: wget
async function testWget() {
  console.log('\n2Ô∏è‚É£ Test avec wget (IPv4):');
  try {
    const start = Date.now();
    const { stdout } = await execAsync(`wget -4 -q -O - --timeout=10 "${NASA_URL}"`);
    const time = Date.now() - start;
    console.log(`   ‚úÖ Succ√®s! Temps: ${time}ms, Taille: ${stdout.length} caract√®res`);
    return true;
  } catch (error) {
    console.log(`   ‚ùå √âchec: ${error.message}`);
    return false;
  }
}

// Test 3: fetch natif
async function testNativeFetch() {
  console.log('\n3Ô∏è‚É£ Test avec fetch natif:');
  console.log(`   Node.js version: ${process.version}`);
  
  if (typeof fetch === 'undefined') {
    console.log('   ‚ùå fetch non disponible (Node.js < 18)');
    return false;
  }
  
  try {
    const start = Date.now();
    const response = await fetch(NASA_URL, {
      signal: AbortSignal.timeout(10000)
    });
    const text = await response.text();
    const time = Date.now() - start;
    console.log(`   ‚úÖ Succ√®s! Temps: ${time}ms, Taille: ${text.length} caract√®res`);
    return true;
  } catch (error) {
    console.log(`   ‚ùå √âchec: ${error.message}`);
    return false;
  }
}

// Test 4: https natif avec IPv4
async function testHttpsNative() {
  console.log('\n4Ô∏è‚É£ Test avec https natif (IPv4 forc√©):');
  
  // Tester d'abord la r√©solution DNS
  try {
    dns.setDefaultResultOrder('ipv4first');
    const addresses = await promisify(dns.resolve4)('data.giss.nasa.gov');
    console.log(`   üì° Adresses IPv4 trouv√©es: ${addresses.join(', ')}`);
  } catch (error) {
    console.log(`   ‚ö†Ô∏è Erreur DNS: ${error.message}`);
  }
  
  return new Promise((resolve) => {
    const start = Date.now();
    const url = new URL(NASA_URL);
    
    const options = {
      hostname: url.hostname,
      port: 443,
      path: url.pathname,
      method: 'GET',
      headers: {
        'User-Agent': 'Mozilla/5.0 (compatible; Node.js test)',
        'Accept': 'text/csv'
      },
      family: 4, // IPv4 uniquement
      timeout: 10000
    };
    
    let data = '';
    
    const req = https.request(options, (res) => {
      console.log(`   üì• R√©ponse HTTP: ${res.statusCode}`);
      
      if (res.statusCode !== 200) {
        console.log(`   ‚ùå √âchec: HTTP ${res.statusCode}`);
        resolve(false);
        return;
      }
      
      res.on('data', (chunk) => {
        data += chunk;
      });
      
      res.on('end', () => {
        const time = Date.now() - start;
        console.log(`   ‚úÖ Succ√®s! Temps: ${time}ms, Taille: ${data.length} caract√®res`);
        resolve(true);
      });
    });
    
    req.on('error', (error) => {
      console.log(`   ‚ùå √âchec: ${error.message}`);
      resolve(false);
    });
    
    req.on('timeout', () => {
      console.log('   ‚ùå √âchec: Timeout');
      req.destroy();
      resolve(false);
    });
    
    req.end();
  });
}

// Ex√©cuter tous les tests
async function runAllTests() {
  const results = {
    curl: await testCurl(),
    wget: await testWget(),
    nativeFetch: await testNativeFetch(),
    httpsNative: await testHttpsNative()
  };
  
  console.log('\nüìä R√©sum√© des tests:');
  console.log('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');
  
  const working = Object.entries(results)
    .filter(([_, success]) => success)
    .map(([method]) => method);
  
  if (working.length > 0) {
    console.log(`‚úÖ M√©thodes fonctionnelles: ${working.join(', ')}`);
    console.log(`\nüí° Recommandation: La m√©thode "${working[0]}" est la plus rapide sur votre syst√®me.`);
  } else {
    console.log('‚ùå Aucune m√©thode n\'a fonctionn√©!');
    console.log('\nüîß Solutions possibles:');
    console.log('   - V√©rifier votre connexion internet');
    console.log('   - V√©rifier les param√®tres de firewall/proxy');
    console.log('   - Installer curl ou wget');
    console.log('   - Mettre √† jour Node.js vers la version 18+');
  }
  
  // Informations syst√®me utiles
  console.log('\nüìã Informations syst√®me:');
  console.log(`   - Node.js: ${process.version}`);
  console.log(`   - OS: ${process.platform} ${process.arch}`);
  
  // V√©rifier IPv6
  const interfaces = os.networkInterfaces();
  const hasIPv6 = Object.values(interfaces).flat().some(i => i.family === 'IPv6');
  console.log(`   - IPv6 support√©: ${hasIPv6 ? 'Oui' : 'Non'}`);
}

runAllTests().catch(console.error);=== ./app/layout.js ===
import "./globals.css";

export const metadata = {
  title: "NASA GISTEMP Temperature Anomaly Visualizer",
  description: "Visualisation des anomalies de temp√©rature globale avec Next.js et Three.js",
};

export default function RootLayout({ children }) {
  return (
    <html lang="fr">
      <body>
        <div className="main-container">
          {children}
        </div>
      </body>
    </html>
  );
}=== ./app/page.js ===
import Navbar from '@/components/Navbar';
import ClimateGlobe from '@/components/ClimateGlobe';
import DataTable from '@/components/DataTable';
import { getAvailableDates, getNasaTableData } from '@/lib/data';

export default async function HomePage() {
  // Ces fonctions s'ex√©cutent sur le serveur !
  const availableDates = await getAvailableDates();
  const tableData = await getNasaTableData();

  console.log("V√©rification des donn√©es sur le SERVEUR (3 premi√®res lignes) :");
  console.log(tableData.slice(0, 3));

  return (
    <>
      <Navbar />
      
      <main>
        {/* Section description - maintenant s√©par√©e et au-dessus */}
        <div className="description-section" id="visualization">
          <div className="container">
            <article>
              <h2>NASA GISTEMP Visualization</h2>
              <p>
                Cette application interactive visualise les anomalies de temp√©rature globale provenant du dataset NASA GISTEMP.
                Les couleurs sur le globe repr√©sentent les √©carts de temp√©rature par rapport √† la p√©riode de r√©f√©rence (1951-1980).
              </p>
              <p><strong>Comment utiliser :</strong></p>
              <ul>
                <li>S√©lectionnez une ann√©e et un mois dans les menus d√©roulants</li>
                <li>Le globe se mettra √† jour pour afficher les anomalies de temp√©rature pour cette p√©riode</li>
                <li>Utilisez votre souris pour faire pivoter, zoomer et d√©placer le globe</li>
                <li>Les couleurs rouges indiquent un r√©chauffement, les bleues un refroidissement</li>
              </ul>
              <div className="color-scale">
                <div className="scale-label">-5¬∞C</div>
                <div className="gradient"></div>
                <div className="scale-label">+5¬∞C</div>
              </div>
              <p>
                NASA GISTEMP (Goddard Institute for Space Studies Surface Temperature Analysis) fournit une estimation des changements 
                de temp√©rature √† la surface du globe.
              </p>
              <p><small>Source des donn√©es : NASA Goddard Institute for Space Studies</small></p>
            </article>
          </div>
        </div>

        {/* Section globe - maintenant pleine largeur */}
        <div className="globe-section">
          {/* Le composant client re√ßoit les donn√©es pr√©-charg√©es du serveur */}
          <ClimateGlobe availableDates={availableDates} />
        </div>

        <div className="data-section" id="data">
          <h2>Donn√©es mensuelles de temp√©rature globale</h2>
          {/* Le composant client re√ßoit les donn√©es pr√©-charg√©es du serveur */}
          <DataTable initialData={tableData} />
        </div>

        <div className="data-section" id="about">
          <h2>√Ä propos de ce projet</h2>
          <p>
            Cette application a √©t√© recr√©√©e avec Next.js 15 (App Router) et Three.js. Elle utilise les Server Components pour le rendu initial et les Server Actions pour les mises √† jour de donn√©es, offrant une exp√©rience rapide et moderne.
          </p>
          <p>
            Le code source est disponible sur <a href="#">GitHub</a>.
          </p>
        </div>
      </main>
    </>
  );
}=== ./app/api/table/route.js ===
// app/api/table/route.js
import { getNasaTableData } from '@/lib/data';

export async function GET(req) {
  const { searchParams } = new URL(req.url);
  const source = searchParams.get('source') || 'global';
  let data = await getNasaTableData(source);

  // Supprimer les lignes parasites comme "Land-Ocean: Global Means"
  if (data.length > 0 && !data[0][0].startsWith('Year')) {
    data = data.slice(1);
  }

  return Response.json(data);
}
=== ./components/DataTable.jsx ===
// components/DataTable.jsx
'use client';

import { useState, useEffect } from 'react';

export default function DataTable({ initialData }) {
  const [tableData, setTableData] = useState(initialData);
  const [sortOrder, setSortOrder] = useState({});
  const [source, setSource] = useState('global');

  useEffect(() => {
    async function fetchData() {
      try {
        const res = await fetch(`/api/table?source=${source}`);
        const data = await res.json();
        setTableData(data);
      } catch (error) {
        console.error("Erreur lors du chargement des donn√©es:", error);
      }
    }
    fetchData();
  }, [source]);

  const sortTableByColumn = (colIndex) => {
    const order = sortOrder[colIndex] === 'desc' ? 'asc' : 'desc';
    setSortOrder({ [colIndex]: order });

    const header = tableData[0];
    let rows = [...tableData.slice(1)];

    const numericSamples = rows.map(row => parseFloat(row[colIndex])).filter(v => !isNaN(v));
    const isNumeric = numericSamples.length > rows.length / 2;

    const parse = (val) => {
      const num = parseFloat(val);
      return isNaN(num) ? -Infinity : num;
    };

    rows.sort((a, b) => {
      if (isNumeric) {
        const aVal = parse(a[colIndex]);
        const bVal = parse(b[colIndex]);
        return order === 'desc' ? bVal - aVal : aVal - bVal;
      } else {
        const aVal = a[colIndex]?.toLowerCase?.() || '';
        const bVal = b[colIndex]?.toLowerCase?.() || '';
        if (aVal < bVal) return order === 'desc' ? 1 : -1;
        if (aVal > bVal) return order === 'desc' ? -1 : 1;
        return 0;
      }
    });

    setTableData([header, ...rows]);
  };

  if (!tableData || tableData.length < 2) {
    return <p>Donn√©es en cours de chargement ou indisponibles...</p>;
  }

  const header = tableData[0];
  const rows = tableData.slice(1);

  return (
    <div style={{ overflowX: 'auto' }}>
      <div style={{ marginBottom: '1rem' }}>
        <label htmlFor="source">Choisir la r√©gion : </label>
        <select id="source" value={source} onChange={(e) => setSource(e.target.value)}>
          <option value="global">Global</option>
          <option value="north">H√©misph√®re Nord</option>
          <option value="south">H√©misph√®re Sud</option>
        </select>
      </div>

      <table className="data-table">
        <thead>
          <tr>
            {header.map((headerText, index) => (
              <th key={index} onClick={() => sortTableByColumn(index)} style={{ cursor: 'pointer' }}>
                {headerText}
              </th>
            ))}
          </tr>
        </thead>
        <tbody>
          {rows.map((row, rowIndex) => (
            <tr key={rowIndex}>
              {row.map((cell, cellIndex) => {
                let style = {};
                if (cellIndex > 0 && !isNaN(parseFloat(cell))) {
                  const temp = parseFloat(cell);
                  if (temp > 0) {
                    const intensity = Math.min(255, Math.floor(temp * 100));
                    style.backgroundColor = `rgba(255, ${255 - intensity}, ${255 - intensity}, 0.7)`;
                  } else if (temp < 0) {
                    const intensity = Math.min(255, Math.floor(Math.abs(temp) * 100));
                    style.backgroundColor = `rgba(${255 - intensity}, ${255 - intensity}, 255, 0.7)`;
                  }
                }
                return <td key={cellIndex} style={style}>{cell}</td>;
              })}
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
}
=== ./components/Navbar.jsx ===
import Link from 'next/link';

export default function Navbar() {
  return (
    <nav>
      <div className="logo">ClimateSphere</div>
      <ul>
        <li><Link href="/">Home</Link></li>
        <li><Link href="#visualization">Visualisation</Link></li>
        <li><Link href="#data">Donn√©es</Link></li>
        <li><Link href="#about">√Ä propos</Link></li>
      </ul>
    </nav>
  );
}=== ./components/ClimateGlobe.jsx ===
'use client';

import { useState, useEffect, useRef, Suspense } from 'react';
import { Canvas, useFrame, extend } from '@react-three/fiber';
import { OrbitControls } from '@react-three/drei';
import * as THREE from 'three';
import { getTemperatureDataAction } from '@/lib/actions';

// Hook pour d√©tecter si on est sur mobile
function useIsMobile() {
  const [isMobile, setIsMobile] = useState(false);
  useEffect(() => {
    const checkMobile = () => setIsMobile(window.innerWidth < 768);
    checkMobile();
    window.addEventListener('resize', checkMobile);
    return () => window.removeEventListener('resize', checkMobile);
  }, []);
  return isMobile;
}

extend({ 
  SphereGeometry: THREE.SphereGeometry,
  MeshLambertMaterial: THREE.MeshLambertMaterial,
  MeshBasicMaterial: THREE.MeshBasicMaterial
});

const Globe = ({ year, month, isVisible, autoRotate, onLoad, globeRef }) => {
  const groupRef = useRef();
  const baseMeshRef = useRef();
  const [temperatureTexture, setTemperatureTexture] = useState(null);
  const [overlayTexture, setOverlayTexture] = useState(null);
  const [isLoading, setIsLoading] = useState(false);
  const [lastLoadedKey, setLastLoadedKey] = useState('');
  
  // ‚úÖ Identifiant unique pour cette instance
  const instanceId = useRef(Math.random().toString(36).substr(2, 9)).current;

  useFrame(() => {
    if (autoRotate && groupRef.current) {
      groupRef.current.rotation.y += 0.001;
    }
  });

  useEffect(() => {
    const currentKey = `${year}_${month}`;
    if (!baseMeshRef.current || isLoading || lastLoadedKey === currentKey) return;
    
    console.log(`üîÑ [${instanceId}] Chargement: ${currentKey}`);
    setIsLoading(true);
    
    // ‚úÖ SOLUTION RADICALE: D√©sactiver compl√®tement le cache de Three.js
    const manager = new THREE.LoadingManager();
    const loader = new THREE.TextureLoader(manager);
    
    // Forcer un URL unique avec timestamp + instance ID
    const uniqueUrl = `/textures/gistemp_${currentKey}.png?instance=${instanceId}&t=${Date.now()}`;

    loader.load(
      uniqueUrl,
      (texture) => {
        console.log(`‚úÖ [${instanceId}] Texture charg√©e: ${currentKey}`);
        
        // ‚úÖ Forcer les param√®tres de texture √† chaque fois
        texture.magFilter = THREE.LinearFilter;
        texture.minFilter = THREE.LinearMipMapLinearFilter;
        texture.wrapS = THREE.ClampToEdgeWrapping;
        texture.wrapT = THREE.ClampToEdgeWrapping;
        texture.flipY = true;
        texture.needsUpdate = true;
        
        // ‚úÖ Marquer la texture comme unique pour √©viter le partage GPU
        texture.uuid = THREE.MathUtils.generateUUID();
        
        setTemperatureTexture(texture);
        
        if (baseMeshRef.current) {
          const material = baseMeshRef.current.material;
          
          // Nettoyer l'ancienne texture
          if (material.map) {
            material.map.dispose();
          }
          
          material.map = texture;
          material.needsUpdate = true;
          
          // ‚úÖ CRUCIAL: Forcer le renouvellement du mat√©riau aussi
          material.uuid = THREE.MathUtils.generateUUID();
        }
        
        setLastLoadedKey(currentKey);
        setIsLoading(false);
      },
      undefined,
      (error) => {
        console.warn(`‚ö†Ô∏è [${instanceId}] Erreur ${currentKey}, fallback...`);
        
        const fallbackUrl = `/textures/default_earth.jpg?instance=${instanceId}&t=${Date.now()}`;
        loader.load(fallbackUrl, (fallbackTex) => {
          fallbackTex.magFilter = THREE.LinearFilter;
          fallbackTex.minFilter = THREE.LinearMipMapLinearFilter;
          fallbackTex.wrapS = THREE.ClampToEdgeWrapping;
          fallbackTex.wrapT = THREE.ClampToEdgeWrapping;
          fallbackTex.flipY = true;
          fallbackTex.needsUpdate = true;
          fallbackTex.uuid = THREE.MathUtils.generateUUID();
          
          setTemperatureTexture(fallbackTex);
          
          if (baseMeshRef.current) {
            const material = baseMeshRef.current.material;
            if (material.map) {
              material.map.dispose();
            }
            material.map = fallbackTex;
            material.needsUpdate = true;
            material.uuid = THREE.MathUtils.generateUUID();
          }
          
          setLastLoadedKey(currentKey);
          setIsLoading(false);
        });
      }
    );

    if (onLoad && lastLoadedKey !== currentKey) {
      getTemperatureDataAction(year, month).then(res => {
        onLoad({
          global: res?.global ?? null,
          north: res?.north ?? null,
          south: res?.south ?? null,
          oni: res?.oni ?? null,
        });
      }).catch(error => {
        console.error(`‚ùå [${instanceId}] Erreur donn√©es:`, error);
        setIsLoading(false);
      });
    }
  }, [year, month, instanceId]);

  useEffect(() => {
    if (overlayTexture) return;
    
    const manager = new THREE.LoadingManager();
    const loader = new THREE.TextureLoader(manager);
    const overlayUrl = `/textures/overlay.png?instance=${instanceId}&t=${Date.now()}`;
    
    loader.load(overlayUrl, (overlayTex) => {
      overlayTex.magFilter = THREE.LinearFilter;
      overlayTex.minFilter = THREE.LinearMipMapLinearFilter;
      overlayTex.anisotropy = 8;
      overlayTex.wrapS = THREE.ClampToEdgeWrapping;
      overlayTex.wrapT = THREE.ClampToEdgeWrapping;
      overlayTex.needsUpdate = true;
      overlayTex.uuid = THREE.MathUtils.generateUUID();
      setOverlayTexture(overlayTex);
    });
  }, [instanceId]);

  useEffect(() => {
    if (globeRef) {
      globeRef.current = {
        group: groupRef.current,
        base: baseMeshRef.current,
        instanceId: instanceId
      };
    }
  }, [globeRef, instanceId]);

  // Cleanup
  useEffect(() => {
    return () => {
      console.log(`üóëÔ∏è [${instanceId}] Nettoyage`);
      if (temperatureTexture) {
        temperatureTexture.dispose();
      }
      if (overlayTexture) {
        overlayTexture.dispose();
      }
    };
  }, [temperatureTexture, overlayTexture, instanceId]);

  return (
    <group ref={groupRef} rotation-x={0.2} visible={isVisible}>
      <mesh ref={baseMeshRef} rotation-x={0.2}>
        <sphereGeometry args={[1, 128, 64]} />
        <meshLambertMaterial
          key={`material-${instanceId}-${year}-${month}`} // ‚úÖ Key unique pour le mat√©riau JSX
          transparent
          color={0xffffff}
          emissive={0x333333}
          map={temperatureTexture}
        />
      </mesh>
      {overlayTexture && (
        <mesh rotation-x={0.2}>
          <sphereGeometry args={[1.001, 128, 64]} />
          <meshBasicMaterial
            key={`overlay-${instanceId}`} // ‚úÖ Key unique pour l'overlay aussi
            map={overlayTexture}
            transparent
            opacity={0.4}
            depthWrite={false}
            blending={THREE.MultiplyBlending}
            alphaTest={0.1}
          />
        </mesh>
      )}
    </group>
  );
};

const Scene = ({ children }) => (
  <>
    <ambientLight intensity={3.0} />
    <directionalLight position={[3, 2, 5]} intensity={2.0} />
    <directionalLight position={[-3, -2, -5]} intensity={1.0} />
    <directionalLight position={[0, 5, 0]} intensity={0.8} />
    <directionalLight position={[0, -5, 0]} intensity={0.8} />
    {children}
  </>
);

export default function CanvasWithControlsOverlay({ availableDates }) {
  const isMobile = useIsMobile();
  const [autoRotate, setAutoRotate] = useState(true);
  const [compareMode, setCompareMode] = useState(false);
  const [selectedYearA, setSelectedYearA] = useState(availableDates.current_year);
  const [selectedMonthA, setSelectedMonthA] = useState(availableDates.current_month);

  const fallbackYearB = availableDates.years.find(y => y !== availableDates.current_year) || availableDates.years[0];
  const [selectedYearB, setSelectedYearB] = useState(fallbackYearB);
  const [selectedMonthB, setSelectedMonthB] = useState('01');
  const [tempsA, setTempsA] = useState({ global: null, north: null, south: null });
  const [tempsB, setTempsB] = useState({ global: null, north: null, south: null });
  const globeRefA = useRef(null);
  const globeRefB = useRef(null);

  const displayTemps = (temps) => {
    return (
      <div style={{ fontSize: '0.85rem', marginTop: '1rem', color: '#ccc' }}>
        <p>üåç Global: {temps.global !== null ? temps.global.toFixed(2) + '¬∞C' : 'N/A'}</p>
        <p>üßä Nord: {temps.north !== null ? temps.north.toFixed(2) + '¬∞C' : 'N/A'}</p>
        <p>üèîÔ∏è Sud: {temps.south !== null ? temps.south.toFixed(2) + '¬∞C' : 'N/A'}</p>
        <p>üåä ONI: {typeof temps.oni === 'number' ? temps.oni.toFixed(2) : 'N/A'}</p>
      </div>
    );
  };

  // ‚úÖ State stable pour √©viter les re-renders infinis
  const [renderKey, setRenderKey] = useState(0);
  
  useEffect(() => {
    setRenderKey(Date.now());
  }, [compareMode]); // Seulement quand le mode change

  const renderCanvas = (year, month, onLoad, refKey, mode = 'solo') => (
    <Canvas
      key={`canvas-${mode}-${year}-${month}-${renderKey}`}
      camera={{ position: [0, 0, 2.5], fov: 75 }}
      gl={{ antialias: true, alpha: true }}
      style={{ width: '100%', height: '50%' }}
    >
      <Suspense fallback={null}>
        <Scene>
          <Globe
            key={`globe-${mode}-${year}-${month}-${renderKey}`}
            year={year}
            month={month}
            isVisible={true}
            autoRotate={autoRotate}
            onLoad={onLoad}
            globeRef={refKey}
          />
        </Scene>
        <OrbitControls enableDamping dampingFactor={0.1} zoomSpeed={0.3} minDistance={2} maxDistance={5} enablePan={false} />
      </Suspense>
    </Canvas>
  );

  return (
    <div style={{
      display: 'flex',
      flexDirection: isMobile ? 'column' : 'row',
      height: '100vh',
      width: '100%'
    }}>
      {/* SIDEBAR */}
      <div style={{
        minWidth: isMobile ? '100%' : '280px',
        maxWidth: isMobile ? '100%' : '320px',
        background: '#111',
        color: '#fff',
        padding: '1rem',
        boxShadow: isMobile ? '0 2px 10px rgba(0,0,0,0.3)' : '2px 0 10px rgba(0,0,0,0.3)',
        zIndex: 5,
        overflowY: 'auto',
        display: 'flex',
        flexDirection: 'column',
        justifyContent: 'space-around'
      }}>
        <div>
          <h3 style={{ marginBottom: '1rem' }}>üìÖ P√©riode A</h3>
          <input type="text" value={selectedYearA} onChange={e => setSelectedYearA(e.target.value)} placeholder="Ann√©e" style={{ width: '100%', marginBottom: '0.5rem', padding: '0.5rem', background: '#222', color: '#fff', border: '1px solid #444' }} />
          <input type="text" value={selectedMonthA} onChange={e => setSelectedMonthA(e.target.value)} placeholder="Mois" style={{ width: '100%', padding: '0.5rem', background: '#222', color: '#fff', border: '1px solid #444' }} />
          {displayTemps(tempsA)}
        </div>

        {compareMode && (
          <div>
            <h3 style={{ marginBottom: '1rem' }}>üìÖ P√©riode B</h3>
            <input type="text" value={selectedYearB} onChange={e => setSelectedYearB(e.target.value)} placeholder="Ann√©e" style={{ width: '100%', marginBottom: '0.5rem', padding: '0.5rem', background: '#222', color: '#fff', border: '1px solid #444' }} />
            <input type="text" value={selectedMonthB} onChange={e => setSelectedMonthB(e.target.value)} placeholder="Mois" style={{ width: '100%', padding: '0.5rem', background: '#222', color: '#fff', border: '1px solid #444' }} />
            {displayTemps(tempsB)}
          </div>
        )}
      </div>

      {/* CANVAS */}
      <div style={{
        flexGrow: 1,
        minWidth: isMobile ? '100%' : '400px',
        maxWidth: '100%',
        height: isMobile ? 'calc(100vh - 300px)' : '100vh',
        display: 'flex',
        flexDirection: 'column',
        position: 'relative',
      }}>
        <div style={{
          position: 'absolute',
          top: '1rem',
          left: '1rem',
          zIndex: 10,
          background: '#222',
          padding: '0.75rem 1rem',
          borderRadius: '8px',
          border: '1px solid #444',
          color: '#fff'
        }}>
          <label style={{ display: 'flex', alignItems: 'center', gap: '0.5rem', marginBottom: '0.5rem' }}>
            <input type="checkbox" checked={compareMode} onChange={e => setCompareMode(e.target.checked)} style={{ accentColor: '#4a90e2' }} />
            Mode comparaison
          </label>
          <label style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
            <input type="checkbox" checked={autoRotate} onChange={e => setAutoRotate(e.target.checked)} style={{ accentColor: '#4a90e2' }} />
            Rotation automatique
          </label>
        </div>

        {compareMode ? (
          <>
            {renderCanvas(selectedYearA, selectedMonthA, setTempsA, globeRefA, 'compare-a')}
            {renderCanvas(selectedYearB, selectedMonthB, setTempsB, globeRefB, 'compare-b')}
          </>
        ) : (
          <Canvas 
            key={`solo-${selectedYearA}-${selectedMonthA}-${renderKey}`}
            camera={{ position: [0, 0, 2.5], fov: 75 }} 
            gl={{ antialias: true, alpha: true }} 
            style={{ width: '100%', height: '100%' }}
          >
            <Suspense fallback={null}>
              <Scene>
                <Globe
                  key={`solo-globe-${selectedYearA}-${selectedMonthA}-${renderKey}`}
                  year={selectedYearA}
                  month={selectedMonthA}
                  isVisible={true}
                  autoRotate={autoRotate}
                  onLoad={setTempsA}
                  globeRef={globeRefA}
                />
              </Scene>
              <OrbitControls enableDamping dampingFactor={0.1} zoomSpeed={0.3} minDistance={2} maxDistance={5} enablePan={false} />
            </Suspense>
          </Canvas>
        )}
      </div>
    </div>
  );
}=== ./lib/actions.js ===
'use server';

import { getTemperatureForDate, getOniIndex } from './data';

export async function getTemperatureDataAction(year, month) {
  try {
    // R√©cup√©ration des 3 temp√©ratures et de l‚ÄôONI en parall√®le
    const [globalTemp, northTemp, southTemp, oni] = await Promise.all([
      getTemperatureForDate(year, month, 'global'),
      getTemperatureForDate(year, month, 'north'),
      getTemperatureForDate(year, month, 'south'),
      getOniIndex(year, month)
    ]);

    const result = {
      temperature: globalTemp, // r√©trocompatibilit√©
      global: globalTemp,
      north: northTemp,
      south: southTemp,
      oni
    };

    console.log('üå°Ô∏è R√©sultat temp√©rature p√©riode A :', result);
    return result;

  } catch (error) {
    console.error(`Erreur dans la Server Action getTemperatureDataAction: ${error.message}`);
    return { 
      error: 'Impossible de r√©cup√©rer les temp√©ratures.',
      temperature: null,
      global: null,
      north: null,
      south: null,
      oni: null
    };
  }
}
=== ./lib/data.js ===
// lib/data.js - Version optimis√©e pour plusieurs sources NASA (GLB, NH, SH) + ONI
import fs from 'fs/promises';
import path from 'path';
import https from 'https';
import dns from 'dns';

dns.setDefaultResultOrder('ipv4first');

const CACHE_DURATION = 2 * 24 * 60 * 60 * 1000; // 48 heures

const NASA_URLS = {
  global: 'https://data.giss.nasa.gov/gistemp/tabledata_v4/GLB.Ts+dSST.csv',
  north: 'https://data.giss.nasa.gov/gistemp/tabledata_v4/NH.Ts+dSST.csv',
  south: 'https://data.giss.nasa.gov/gistemp/tabledata_v4/SH.Ts+dSST.csv',
};

const CACHE_FILES = {
  global: path.join(process.cwd(), 'cache_global.csv'),
  north: path.join(process.cwd(), 'cache_nh.csv'),
  south: path.join(process.cwd(), 'cache_sh.csv'),
};

const fetchLocks = {
  global: { isFetching: false, promise: null },
  north: { isFetching: false, promise: null },
  south: { isFetching: false, promise: null },
};

const ONI_URL = 'https://www.cpc.ncep.noaa.gov/data/indices/oni.ascii.txt';
const CACHE_FILE_ONI = path.join(process.cwd(), 'cache_oni.txt');

// --- NASA FETCH ---
function fetchNasaData(source = 'global') {
  return new Promise((resolve, reject) => {
    const url = new URL(NASA_URLS[source]);
    console.log(`üì± R√©cup√©ration des donn√©es NASA (${source}) via ${url.hostname}`);

    const options = {
      hostname: url.hostname,
      port: 443,
      path: url.pathname,
      method: 'GET',
      headers: {
        'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7)',
        'Accept': 'text/csv,*/*',
        'Accept-Language': 'fr-FR,fr;q=0.9,en;q=0.8',
        'Cache-Control': 'no-cache'
      },
      family: 4,
      timeout: 30000
    };

    let data = '';

    const req = https.request(options, (res) => {
      console.log(`üóïÔ∏è R√©ponse re√ßue: HTTP ${res.statusCode}`);

      if (res.statusCode >= 300 && res.statusCode < 400 && res.headers.location) {
        console.log(`‚Ü™ Redirection vers: ${res.headers.location}`);
        fetchNasaData(source).then(resolve).catch(reject);
        return;
      }

      if (res.statusCode !== 200) {
        reject(new Error(`Erreur HTTP ${res.statusCode}: ${res.statusMessage}`));
        return;
      }

      res.setEncoding('utf8');
      res.on('data', (chunk) => data += chunk);
      res.on('end', () => {
        console.log(`‚úÖ Donn√©es re√ßues: ${data.length} caract√®res`);
        resolve(data);
      });
    });

    req.on('error', (error) => {
      console.error(`‚ùå Erreur de connexion: ${error.message}`);
      reject(error);
    });

    req.on('timeout', () => {
      console.error('‚ùå Timeout de la requ√™te');
      req.destroy();
      reject(new Error('Timeout de connexion (30s)'));
    });

    req.end();
  });
}

export async function fetchAndCacheNasaData(source = 'global') {
  const CACHE_FILE = CACHE_FILES[source];
  const lock = fetchLocks[source];
  const stats = await fs.stat(CACHE_FILE).catch(() => null);
  const age = stats ? Date.now() - stats.mtimeMs : Infinity;

  if (age < CACHE_DURATION) {
    console.log(`‚úÖ Cache valide (${source}) (√¢ge: ${Math.round(age / 60000)} min)`);
    return;
  }

  if (lock.isFetching && lock.promise) {
    console.log(`‚è≥ Attente d'une mise √† jour du cache (${source}) d√©j√† en cours...`);
    await lock.promise;
    return;
  }

  lock.isFetching = true;
  lock.promise = (async () => {
    try {
      console.log(`üöÄ D√©but mise √† jour du cache (${source}) (√¢ge: ${Math.round(age / 60000)} min)`);
      const rawData = await fetchNasaData(source);

      if (!rawData || rawData.length < 1000 || !rawData.includes('Year,Jan')) {
        throw new Error("Donn√©es invalides ou incompl√®tes");
      }

      const cleanedData = rawData.replace(/\*\*\*/g, '');
      await fs.writeFile(CACHE_FILE, cleanedData);
      console.log("üìÇ Cache mis √† jour avec succ√®s !");
    } catch (error) {
      console.error(`‚ùå √âchec de la mise √† jour du cache (${source}): ${error.message}`);

      if (stats && stats.size > 0) {
        console.warn("‚ö†Ô∏è Utilisation du cache expir√©");
        return;
      }

      console.warn("üè¢ Cr√©ation d'un cache d'urgence minimal...");
      const emergencyData = `Year,Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec,J-D,D-N,DJF,MAM,JJA,SON\n2024,1.20,1.37,1.28,1.11,1.05,1.17,1.21,1.23,1.17,1.15,1.12,1.15,1.19,,1.23,1.15,1.20,1.15\n2023,0.87,0.97,1.20,1.00,0.93,1.08,1.19,1.27,1.49,1.37,1.46,1.52,1.19,1.15,0.95,1.04,1.18,1.44\n2022,0.91,0.89,1.05,0.84,0.84,0.92,0.93,0.95,0.90,0.97,0.72,0.79,0.89,0.94,1.16,0.91,0.93,0.86`;
      await fs.writeFile(CACHE_FILE, emergencyData);
      console.log("‚úÖ Cache d'urgence cr√©√©");
    } finally {
      lock.isFetching = false;
      lock.promise = null;
    }
  })();

  return lock.promise;
}

// --- Parsing CSV NASA ---
async function parseCSV(source = 'global') {
  await fetchAndCacheNasaData(source);
  const CACHE_FILE = CACHE_FILES[source];
  const csvData = await fs.readFile(CACHE_FILE, 'utf-8');
  const lines = csvData.trim().split('\n');
  const dataLines = lines.slice(1);
  return dataLines.map(line => line.split(',').map(cell => cell.trim()));
}

export async function getAvailableDates(source = 'global') {
  const parsedData = await parseCSV(source);
  const years = parsedData.map(row => row[0]).filter(Boolean).map(Number);

  const lastValid = [...parsedData].reverse().find(row =>
    row.some((cell, i) => i > 0 && !isNaN(parseFloat(cell)))
  );

  const current_year = lastValid?.[0];
  const current_month = (() => {
    if (!lastValid) return '01';
    let lastMonthIndex = -1;
    for (let i = 1; i <= 12; i++) {
      if (!isNaN(parseFloat(lastValid[i]))) {
        lastMonthIndex = i;
      }
    }
    return String(lastMonthIndex).padStart(2, '0');
  })();

  const months = [
    { value: "01", name: "Jan" }, { value: "02", name: "F√©v" }, { value: "03", name: "Mar" },
    { value: "04", name: "Avr" }, { value: "05", name: "Mai" }, { value: "06", name: "Juin" },
    { value: "07", name: "Juil" }, { value: "08", name: "Ao√ª" }, { value: "09", name: "Sep" },
    { value: "10", name: "Oct" }, { value: "11", name: "Nov" }, { value: "12", name: "D√©c" }
  ];

  return {
    years: years.sort((a, b) => b - a),
    months,
    current_year,
    current_month
  };
}

export async function getNasaTableData(source = 'global') {
  await fetchAndCacheNasaData(source);
  const CACHE_FILE = CACHE_FILES[source];
  const csvData = await fs.readFile(CACHE_FILE, 'utf-8');
  const lines = csvData.trim().split('\n');
  const header = lines[0].split(',').map(cell => cell.trim());
  const dataLines = lines.slice(1);
  const parsedData = dataLines.map(line => line.split(',').map(cell => cell.trim()));
  return [header, ...parsedData];
}

export async function getTemperatureForDate(year, month, source = 'global') {
  const parsedData = await parseCSV(source);
  const monthIndex = parseInt(month, 10);
  if (monthIndex < 1 || monthIndex > 12) return null;
  const colIndex = monthIndex;
  const yearRow = parsedData.find(row => row[0] === String(year));
  if (!yearRow || !yearRow[colIndex] || yearRow[colIndex] === '') return null;
  return parseFloat(yearRow[colIndex]);
}

// --- ONI FETCH & PARSE ---
export async function fetchAndCacheOniData() {
  const stats = await fs.stat(CACHE_FILE_ONI).catch(() => null);
  const age = stats ? Date.now() - stats.mtimeMs : Infinity;
  if (age < CACHE_DURATION) return;

  try {
    const raw = await new Promise((resolve, reject) => {
      const url = new URL(ONI_URL);
      const options = {
        hostname: url.hostname,
        path: url.pathname,
        method: 'GET',
        family: 4,
        timeout: 10000
      };
      let data = '';
      const req = https.request(options, res => {
        res.on('data', chunk => data += chunk);
        res.on('end', () => resolve(data));
      });
      req.on('error', reject);
      req.on('timeout', () => {
        req.destroy();
        reject(new Error("Timeout ONI"));
      });
      req.end();
    });

    console.log("‚úÖ Contenu ONI r√©cup√©r√©, √©criture en cours");
    await fs.writeFile(CACHE_FILE_ONI, raw);
    console.log("‚úÖ Cache ONI mis √† jour");
  } catch (err) {
    console.error("‚ùå √âchec r√©cup√©ration ONI:", err.message);
  }
}

const oniSeasonByMonth = {
  '01': 'NDJ', '02': 'DJF', '03': 'JFM', '04': 'FMA',
  '05': 'MAM', '06': 'AMJ', '07': 'MJJ', '08': 'JJA',
  '09': 'JAS', '10': 'ASO', '11': 'SON', '12': 'OND'
};

function getOniSeasonAndYear(year, month) {
  const season = oniSeasonByMonth[month];
  const y = parseInt(year, 10);
  if (season === 'NDJ') return { season, year: y - 1 };
  return { season, year: y };
}

export async function getOniIndex(year, month) {
  await fetchAndCacheOniData();
  const content = await fs.readFile(CACHE_FILE_ONI, 'utf-8');

  const { season, year: oniYear } = getOniSeasonAndYear(year, month);
  const lines = content.trim().split('\n');

  console.log(`üîé Recherche ONI pour ${oniYear} ${season}...`);

  for (const line of lines) {
    const parts = line.trim().split(/\s+/);
    if (parts.length < 4) continue;

    const tri = parts[0].trim().toUpperCase(); // ex: DJF
    const yr = parseInt(parts[1]);             // ex: 1950
    const val = parseFloat(parts[3]);          // ex: -1.53


    if (tri === season.toUpperCase() && yr === oniYear) {
      console.log(`‚úÖ Trouv√© ONI: ${val} (${season} ${oniYear})`);
      return isNaN(val) ? null : val;
    }
  }

  console.warn(`‚ùå Aucune donn√©e ONI trouv√©e pour ${oniYear} ${season}`);
  return null;
}